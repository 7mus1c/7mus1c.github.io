# 栈是什么

栈是一种后进先出的数据结构，也可以说先进后出。

比如像是蜂窝煤，只能从顶部取走，不能从底部取走。
放入也是只能从自顶向下放入。

JavaScript 没有栈，但是可以用数组来实现。通过数组的 push 和 pop 方法。

```javascript
const stack = [];
stack.push(1); // 入栈
stack.push(2); // 入栈
stack.push(3); // 入栈

const item1 = stack.pop(); // 3 出栈
const item2 = stack.pop(); // 2 出栈
const item3 = stack.pop(); // 1 出栈
```

小技巧：可以通过 vscode 的调试功能进行打断点和调试。

## 什么场景下用栈

所有需要后进先出的场景
比如：十进制转二进制、判断字符串中的括号是否有效、函数调用堆栈等

### 十进制转二进制

规则：除以 2，余数倒序排列

比如 35/2 得 17 余 1， 17/2 得 8 余 1， 8/2 得 4 余 0， 4/2 得 2 余 0， 2/2 得 1 余 0， 1/2 得 0 余 1 就得出最终余数 110001，倒叙就是二进制为 100011。
此时就可以把余数依次入栈，然后再出栈，就可以实现余数的倒叙输出。

### 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串里的括号是否有效（有效的闭合）。

比如 s = '()'， s = '()[]{}'， s = '((()))' 这些都是有效的。
再比如 s = '([)]'， s = '{[])'， s = '([' 这些都是无效的。

规律：越靠右的左括号，对应的右括号越靠左。
遇见左括号就入栈，遇见右括号就出栈，最后栈为空，则有效。

### 函数调用堆栈

最后调用的函数，最先被执行完。
比如函数 A 调用函数 B，函数 B 调用函数 C，函数 C 执行完，函数 B 执行完，函数 A 执行完。

这就符合栈的后进先出的原则。

## 总结

所有有后进先出的场景都是可以用栈来解决问题。

##  20.有效的括号
```ts
/**
 * 判断括号字符串是否有效
 * 解题思路：
 * 1. 对于没有闭合的左括号而言，越靠右的左括号越先被闭合。
 * 2. 满足后进先出的特性。因此使用栈。
 * 解题步骤：
 * 1. 新建一个栈
 * 2. 遍历字符串中的每个字符
 * 3. 如果是左括号，则入栈
 * 4. 遇到右括号，判断是否和栈顶的左括号匹配
 *    - 如果匹配，则出栈
 *    - 如果不匹配，或者栈为空，则返回 false
 * 5. 遍历结束后，如果栈为空，则返回 true，否则返回 false
 * @param {string} s 字符串
 * @returns {boolean} 是否有效
 */
function isValid(s: string): boolean {
  // 优化：如果字符串长度为奇数，则一定不匹配
  if (s.length % 2 !== 0) return false;

  const stack: string[] = [];
  for (let i = 0; i < s.length; i++) {
    if (s[i] === "(" || s[i] === "{" || s[i] === "[") {
      stack.push(s[i]);
    } else {
      const top = stack.pop();
      if (!top) {
        return false; // 如果栈为空，说明没有对应的左括号
      }
      if (
        (top === "(" && s[i] !== ")") ||
        (top === "{" && s[i] !== "}") ||
        (top === "[" && s[i] !== "]")
      ) {
        return false;
      }
    }
  }

  return stack.length === 0;
} 
```
时间复杂度: O(n)，其中 n 是字符串 s 的长度。我们需要遍历字符串中的每个字符一次。
空间复杂度: O(n)，在最坏情况下，栈中可能存储所有的左括号，因此空间复杂度为 O(n)。
