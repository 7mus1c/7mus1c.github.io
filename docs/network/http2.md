# HTTP协议 下

## 密码学入门

为什么要学一点密码学相关的知识，其实是为了了解HTTPS的。

密码都知道，那密码学又是什么？密码学就是专门处理信息的，不能让别人轻易的知道。

密码学的处理对象是数字和字符串。字符串好理解，数字是承载信息的基本载体，可以是一串有意义的数字，也可以承载其他信息，比如视频、音频、图片等信息。在计算机里所有的信息都是数字。就连字符串也是数字。字符串对应的是**ASCII**码的集合。

密码学的第一个概念就是加密。平时压缩一个文件打压缩包，压缩的时候可以加密码，即使强行打开也可能是乱码。这个过程就是加密。还有另外一种，登录的时候给密码做一个MD5加密。严格来说它不叫加密，它叫散列，它是没有办法解密的。只有能加密和逆向解密的才是加密。MD5它其实是提取特征指纹。

散列是一种一旦数据转换为其他形式的将永远无法恢复的加密技术。

加密分为两种：

- 对称加密(AES、DES、3DES)
  - 加密和解密的算法是相同的，密钥也是相同的
  - 加密解密的时候密钥是一样的，密钥在传输的过程容易丢失
- 非对称加密(RSA)
  - 在加密的时候密钥是专门用来加密的，解密的时候密钥是用来解密的，不能互换
  - 加密的密钥可以公开，解密的密钥是不能公开且私有的。公开的密钥叫公钥，私有的叫私钥

加密的过程：明文 -> 加密（加密密钥、加密算法）-> 密文

解密的过程：密文 -> 解密（解密密钥、解密算法）-> 明文

有的时候不得已需要对称加密，那就需要一种策略密钥交换算法：

Deffie-Hellman算法，是一种著名的协商算法，这种算法可以使信息交换的双方通过公开的非安全网络协商生成安全的共享密钥。

### 证书签发机构（CA）

签发机构简称CA是大家都信任的第三方，CA一般都是安全公司，用来做身份认证。它会给网站签发一个数字证书，通过证书来完成密钥交换。实际上是用非对称加密算法完成数据加密密钥的安全交换。

如何知道服务器是否合法，就是浏览器去检查证书。会根据当前证书的上一级证书去验证，一步一步验证上去，直到找到根证书，根证书都是内置在系统内部的。

CA的工作流程：：

1. 通过域名：example.com 向CA申请TLS证书。例如Digicert公司。
2. CA公司为域名创建证书，证书里边包含必要的数据，比如服务器名称，服务器公钥等。
3. CA创建证书的哈希值，并使用自己的私钥(CA的私钥)进行加密
4. 浏览器和操作系统自带Digicert等权威机构的公钥。
5. 浏览器收到证书的时候，用公钥和签名生成哈希值，再用指定的算法再生成散列，如果这两个哈希值匹配，则签名验证成功，证书可信。
6. 现在浏览器可以使用证书指定的域名的公钥进行身份验证过程。浏览器就会生成连接是安全的。

### SSL/TLS协议

现在广泛使用的是TLS协议，它是传输层安全性协议。SSL是安全套阶层。TLS是SSL衍生出来的。它们是在ISO协议的会话层。

HTTPS是带加密的HTTP，它是通依靠SSL提供的库实现的加密，现在基本上使用的都是TLS协议。它是一种集合，包含了四种核心协议：握手协议、密钥配置切换协议、应用数据协议及报警协议。

TLS协议的工作范畴:

- TLS适用于对称密钥
- 对称密钥可以通过安全密钥交换算法共享
- 如果请求被拦截（受到攻击），密钥交换可能会被欺骗（被拦截后篡改）
- 用数字签名进行身份验证
- 通过证书构建信任链

- HTTPS是基于SSL的协议
- SSL协议是记录协议
- 握手协议是SSL的子协议
- TLS是SSL的后续版本

## HTTPS协议分析

浏览器是一种单项验证的，只需要浏览器验证服务端，但是在HTTPS是双向认证的，浏览器和服务端互相认证。

### TLS的握手过程：

1. ClientHello：客户端发起连接，发送支持SSL/TLS最高的版本和加密算法集合以及压缩方法集合等信息给服务器
2. ServerHello：服务端收到后，决定双方都支持的SSL/TLS版本和加密算法及压缩方法返回给客户端
3. SendCertificate（可选）：服务器把自己的证书发送给客户端，当非首次连接可以选择是否重新发送
4. RequestCertificate（可选）：是否选择双向验证，服务器是否要求客户端发送回来证书
5. ServerHelloDone：服务器通知客户端初始协商结束
6. ResponseCertificate（可选）：如果服务器向客户端要证书，客户端向服务器发送证书
7. ClientKeyExchange: 客户端使用服务器的公钥，对客户端公钥和密钥种子加密，再发送给服务器。服务器公钥是在证书里的，客户端公钥是在客户端的，密钥种子是密钥交换算法里边的
8. CertificateVerify（可选）：如果选择双向验证，客户端用本地私钥生成数字签名，发给服务端，服务端进行验证
9. CreateSecreKey：双方基于密钥种子生成通讯密钥。
10. ChangeCipherSpec：客户端通知服务器已讲通讯方式切换到加密模式
11. Finished：客户端做好加密通讯的准备
12. ChangeCipherSpec：服务器通知客户端已将通讯方式切换到加密模式
13. Finished：服务器做好加密通讯的准备
14. Encrypted/DecryptedData：双方使用客户端密钥，通过对称加密算法对通讯内容进行加密
15. ClosedConnection：通讯结束后，任何一方发送断开SSL连接。

## HTTP2协议分析

HTTP1的传输是文字传输，传输头的格式是固定的，这样就会造成了如果服务端容错做不了好会导致崩溃。另外HTTP1的内容是会被压缩的，但是头并不会压缩，随着头里的内容越来越多，性能就会有缺陷。比如TCP层面上，进行传输的时候导致阻塞，延迟加高。

HTTP2 针对HTTP1 性能增加了。其他的并无明显变化，但是在数据封装的时候进行了格式化（分帧），分帧是把文本转成了二进制。引入了一个新的二进制分帧层，与原数据相比，二进制明显更加小。

### 特点：

- 使用二进制传输，更高效，更紧凑
- 对报头进行了压缩，降低了开销
- 多路复用，一个网络链接的并行请求（TCP层面）
- 服务器主动推送，减少请求延迟
- 默认使用加密

### 二进制的分帧层

它是一种封装手段，它定义了HTTP的数据以什么形式去传输。HTTP1是文本加空格和回车换行符传输。HTTP2报头封一个帧，它叫Header帧。内容封一个帧，Data帧。它们用二进制符号分割，或者偏移量分割。它这个帧的内容都是二进制的。

### 多路复用

多路复用涉及到了通讯上面的，它是在TCP上面进行的优化。HTTP1.1对1升级就是多了一个长连接。它优化了TCP的反复握手和挥手的过程。不是长连接的时候几次传输就需要创建几个链接，然后每次又进行多次的握手挥手。长连接只需要一次握手挥手就行了，节省了好多I/O开销。长连接传文件一个文件一个文件的传，创建链路之后一个文件一个文件的传，这个叫串行。这些文件都在一条链路上传输。链路不断的话会减少服务器的I/O开销。服务器是I/O密集型。它的压力主要在于这个soket上，断开链接，建立链接消耗是很大的。要把这个消耗省下来用到数据传输上。TCP的连接和断开它属于带外流量（有效传输之外的耗损）。

HTTP2也是一个链路上传输，去复用。但是它的传输是并行传输。串行传输的时候是一个一个的传，它的问题很明显，访问一个网站的时候，除了页面骨架，后续的资源是没有互相的依赖性的。它们的共同依赖者是页面骨架。所以后续的资源谁先谁后并不重要。串行传输的时候网速如果慢会导致文件加载完了才能去加载下一个，如果是图片就非常明显。这问题就需要用到多路复用。

HTTP2只有一条链路，做不到所有的文件同时传输，它只有一个TCP连接。这个时候就需要把文件切块。把一个文件分成若干块，按照顺序去发。如果有多个文件，也被切成块，他们会交替传输。

| 文件1.1 | 文件2.1 | 文件3.1 |
| ------- | ------- | ------- |
| 文件1.2 | 文件2.2 | 文件3.2 |
| 文件1.3 | 文件2.3 | 文件3.3 |

1.1 -> 2.1 -> 3.1 ->1.2 -> 2.2 .....

交错传输文件间隔顺序就很好，不会造成阻塞问题。这样就可以用一个连接发送一批请求，收的时候就可以一批收到网络延迟就大大减少。

### 服务器推送

服务器推送实际上是对HTTP协议的扩充。它支持一对多推送，比如说一些要求实时性数据的场景下。比如一些股票实时的，或者实时新闻，还有游戏，比如说实时服务器一对多，可以实时推送数据。

推送资源可以推送哪些：

- 由客户端做缓存的一些东西
- 只要多个页面在一个域下，可以复用推送
- 服务器可以设置推送的优先级，先推谁后推谁
- 客户端可以拒绝推送

### HTTP2的伪头字段

伪头字段 :path: / 这样冒号开头的字段，伪头字段不是存在于头字段里边。只不过显示出来的像个头字段。他们就是原来的请求行，把请求行和响应行变了一下，然后为了跟HTTP1去兼容，同时又给请求头分了帧。放到了Header帧里边。为了能拿出来才出现了 ':' 它总共有5个伪头字段

- :method 请求方法
- :scheme: 对应的是协议
- :authority 域
- :path 指的是方法后边的资源路径
- :status 状态码

HTTP1.1 和 2 怎么切换：访问一个网站的时候，服务器主动发动升级协议的协商。浏览器会先发送1.1发请求，服务器收到之后会收到协议升级协商的响应。客户端收到协议升级的响应之后，自己决定是否使用升级。

## 了解HTTP3

HTTP3 不向前兼容，3是一个全新的协议，它运行在QUIC之上。 它之前叫做 HTTP-over-QUIC。QUIC是一个协议，基于UDP。意味着它不需要握手了，节省了三次握手的时间。UDP不依靠链路的，发出的包可以无序。

### 队首阻塞问题

1和2发送和接受是要严格按照包序号的。如果发送了3个包，第三个包如果在传输中丢了，另一方会要求发包放立刻重发。接收方是无法知道这个包丢没有丢，只能认为是超时。一旦3超时了，就要求发包方超时重发。在TCP机制里面有超时重发。在重发3的时候后边的4是发布过来的。这就造成了堵塞了。

UDP可以是给包编号的，发的时候接收方不在意哪个先哪个后，只在意包收全没有。这些包都收到以后去组装，组装的时候发现少了一个才会要求重发，这边就减少了超时等待的时间。性能又少了很多。

HTTP3在移动端是极有优势的，在WIFI和移动网络切换的过程，如果是TCP连接的时候必须要断掉，因为TCP在进行连接的时候要一直维持连接。如果IP改变了，那这个包肯定到不了原来的IP上了。所以它要先强行断开，再等老半天。QUIC就不一样了，在网络切换之前发了3个包，服务器回了两个包，正好网络切了，再发了5个包，服务器又回了5个包，中间有一个包丢了。服务器会发现有一个包没有返回响应，那就会给重发这个包。如果新的IP服务器不知道，那肯定发不过来。那么客户端也有重发机制，客户端迟迟等不到服务器的包，也会要求服务器重新发。 QUIC不会丢包延迟等待，这是它最大的特性。
